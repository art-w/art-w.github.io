<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Wait (webdriver.Webdriver.S.Wait)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">webdriver</a> &#x00BB; <a href="../../index.html">Webdriver</a> &#x00BB; <a href="../index.html">S</a> &#x00BB; Wait</nav><h1>Module <code>S.Wait</code></h1><p>Even though the browser attempts to complete most operations before giving back control, some commands might trigger too soon and raise an error. The recommended strategy is to sleep and retry the operation repeatedly until it succeeds.</p></header><aside><p>The default parameters are:</p><ul><li><code>?sleep = 50ms</code> is the amount of time to <a href="../index.html#val-sleep"><code>sleep</code></a> before retrying the command.</li><li><code>?max = 3000ms</code> is the maximum total time spend waiting in between retries (in milliseconds).</li><li><code>?errors</code> are the recoverable errors. By default:</li></ul><pre><code class="ml">[ `element_not_interactable
; `invalid_element_state
; `move_target_out_of_bounds
; `no_such_alert
; `no_such_cookie
; `no_such_element
; `no_such_frame
; `no_such_window
]</code></pre><p>The others WebDriver errors are more indicative of an issue in your automation script.</p></aside><dl><dt class="spec value" id="val-retry"><a href="#val-retry" class="anchor"></a><code><span class="keyword">val</span> retry : <span>?&#8288;max:int</span> <span>&#45;&gt;</span> <span>?&#8288;sleep:int</span> <span>&#45;&gt;</span> <span>?&#8288;errors:<span><a href="../Error/index.html#type-error">Error.error</a> list</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-cmd">cmd</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="../index.html#type-cmd">cmd</a></span></code></dt><dd><p><code>retry cmd</code> attempts to execute <code>cmd</code>. If it fails with a recoverable error, the execution sleeps for a bit to give the browser a chance to catch up, then the operation is retried until it succeeds or the <code>max</code> time is reached.</p><pre><code class="ml">let* e = find_first `css &quot;#id&quot; in (* might raise `no_such_element *)
(* vs *)
let* e = Wait.retry @@ find_first `css &quot;#id&quot; in (* deterministic *)</code></pre></dd></dl><dl><dt class="spec value" id="val-until"><a href="#val-until" class="anchor"></a><code><span class="keyword">val</span> until : <span>?&#8288;max:int</span> <span>&#45;&gt;</span> <span>?&#8288;sleep:int</span> <span>&#45;&gt;</span> <span>?&#8288;errors:<span><a href="../Error/index.html#type-error">Error.error</a> list</span></span> <span>&#45;&gt;</span> <span>bool <a href="../index.html#type-cmd">cmd</a></span> <span>&#45;&gt;</span> <span>unit <a href="../index.html#type-cmd">cmd</a></span></code></dt><dd><p><code>until condition</code> behaves like <code>retry condition</code>, but the predicate must also be satisfied at the end.</p><p>Raises <code>`unspecified &quot;condition&quot;</code> if the <code>max</code> time is reached and the condition is still unsatisfied.</p><pre><code class="ml">let* url = current_url in
let* () = send_keys input (&quot;hello&quot; ^ Key.Enter) in
let* () = Wait.until @@ map (( &lt;&gt; ) url ) current_url in
(* blocks until the form is actually submitted. *)</code></pre></dd></dl></div></body></html>