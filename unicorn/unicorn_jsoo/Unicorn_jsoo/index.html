<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Unicorn_jsoo (unicorn_jsoo.Unicorn_jsoo)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../index.html">unicorn_jsoo</a> &#x00BB; Unicorn_jsoo</nav><header class="odoc-preamble"><h1>Module <code><span>Unicorn_jsoo</span></code></h1><p>Unicorn provides a small algebra of seven combinators to define GUI applications:</p><ul><li><code>empty</code> for when you don't want anything drawn</li><li><code>a &amp; b</code> when you want to display two or more widgets</li><li><code>iso i w</code> to adapt an existing widget <code>w</code> to a different type (similar to &quot;map&quot;)</li><li><code>on lens w</code> when you want to edit a product/tuple/record</li><li><code>into prism w</code> for pattern matching over sum types</li><li><code>stateful s w</code> to hide the internal state of the widget <code>w</code></li><li><code>dynamic</code> for complete control over the widget's position, movement, creation, history, etc.</li></ul><p>These combinators are the glue to assemble complex applications out of smaller widgets. The <code>jsoo</code> (<code>js_of_ocaml</code>) backend additionnally provides the primitive widgets and HTML support.</p></header><nav class="odoc-toc"><ul><li><a href="#algebra">Algebra</a><ul><li><a href="#useful-combinators">Useful combinators</a></li><li><a href="#recursive-definitions">Recursive definitions</a></li></ul></li><li><a href="#html-primitive-widgets">HTML primitive widgets</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>!'a t</span></span></code></div><div class="spec-doc"><p>The type of a widget that can render and update values of type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-run" class="anchored"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : <span>?id:string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>run w x</code> renders the widget <code>w</code> with the initial state <code>x</code>, then proceed to update it in reaction to user events. It's the main loop that drives the GUI application, so you probably want to call it only once.</p><ul><li>If <code>?id</code> is specified, the widget renders in the HTML node with the corresponding <code>id</code> attribute. Otherwise, the widget is appended to the HTML body of the webpage.</li></ul></div></div><h2 id="algebra"><a href="#algebra" class="anchor"></a>Algebra</h2><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The <code>empty</code> widget, invisible and ineffective.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&amp;)" class="anchored"><a href="#val-(&amp;)" class="anchor"></a><code><span><span class="keyword">val</span> (&amp;) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>a &amp; b</code> displays both widgets <code>a</code> and <code>b</code> side by side.</p><ul><li>identity: <code>∀ w. empty &amp; w == w == w &amp; empty</code></li><li>associative: <code>∀ a b c. a &amp; (b &amp; c) == a &amp; b &amp; c == (a &amp; b) &amp; c</code></li><li>NOT commutative, as <code>b &amp; a</code> displays the widgets in a different order.</li></ul></div></div><p>The polymorphic <code>'a</code> in an <code>'a t</code> widget is invariant: It is consummed when rendering, but also produced in reaction to user events. As such, we always need pair of functions to &quot;map&quot; over it:</p><div class="odoc-spec"><div class="spec value" id="val-iso" class="anchored"><a href="#val-iso" class="anchor"></a><code><span><span class="keyword">val</span> iso : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="../../optic/Optic/index.html#type-iso">Optic.iso</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>iso i w</code> maps the isomorphism <code>i</code> over the widget <code>w</code>.</p><ul><li>identities: <code>∀ i. iso i empty == empty</code> and <code>∀ w. map Iso.id w == w</code></li><li>composition: <code>∀ i j w. iso i (iso j w) == map (Iso.compose i j) w</code></li><li>distributive: <code>∀ i a b. iso i a &amp; iso i b == iso i (a &amp; b)</code></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-on" class="anchored"><a href="#val-on" class="anchor"></a><code><span><span class="keyword">val</span> on : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="../../optic/Optic/index.html#type-lens">Optic.lens</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>on lens w</code> zooms on a sub-field of the state <code>'a</code> with the <code>lens</code> and renders/updates it with the widget <code>w</code>.</p><ul><li>identities: <code>∀ lens. on lens empty == empty</code> and <code>∀ w. on Lens.id w == w</code></li><li>composition: <code>∀ l1 l2 w. on l1 (on l2 w) == on (Lens.compose l1 l2) w</code></li><li>distributive: <code>∀ lens a b. on lens a &amp; on lens b == on lens (a &amp; b)</code></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-into" class="anchored"><a href="#val-into" class="anchor"></a><code><span><span class="keyword">val</span> into : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="../../optic/Optic/index.html#type-prism">Optic.prism</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>into prism w</code> pattern matches the state <code>'a</code> with the <code>prism</code>, to render the widget <code>w</code>. If the prism fails, then it renders <code>empty</code>.</p><ul><li>identities: <code>∀ prism. into prism empty == empty</code> and <code>∀ w. into Prism.id w == w</code></li><li>composition: <code>∀ p1 p2 w. into p1 (on p2 w) == into (Prism.compose p1 p2) w</code></li><li>distributive: <code>∀ prism a b. into prism a &amp; into prism b == into prism (a &amp; b)</code></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-case" class="anchored"><a href="#val-case" class="anchor"></a><code><span><span class="keyword">val</span> case : <span><span><span>( <span class="type-var">'a</span>, <span class="type-var">'b</span> )</span> <a href="../../optic/Optic/index.html#type-prism">Optic.prism</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>case prism w</code> is the same as <code>into prism w</code>, but the internal state of the widget <code>w</code> is reset when the prism is not satisfied.</p><ul><li>definition: <code>∀ p w. into p w == stateful w (case Prism.(product id p) dynamic)</code></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-stateful" class="anchored"><a href="#val-stateful" class="anchor"></a><code><span><span class="keyword">val</span> stateful : <span><span class="type-var">'s</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'s</span> * <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>stateful s w</code> encapsulates the internal state of the widget <code>w</code> with an initial value <code>s</code>.</p><ul><li>identities: <code>∀ s. stateful s empty == empty</code> and <code>∀ s w. stateful s (on Lens.snd w) == w</code></li><li>composition: <code>∀ s1 s2 w. stateful s1 (stateful s2 w) == stateful (s1, s2) (iso Iso.assoc w)</code></li><li>distributive: <code>∀ s a b. stateful s a &amp; b == stateful s (a &amp; on Lens.snd b)</code> and <code>∀ s a b. a &amp; stateful s b == stateful s (on Lens.snd a &amp; b)</code></li><li>commutative: <code>∀ i s w. iso i (stateful s w) = stateful s (iso (Iso.product id i) w)</code> and same for lenses and prisms.</li></ul><p>However, internal state is not shared: <code>stateful s a &amp; stateful s b =/= stateful s (a &amp; b)</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dynamic" class="anchored"><a href="#val-dynamic" class="anchor"></a><code><span><span class="keyword">val</span> dynamic : <span><span>(<span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>dynamic</code> renders and updates a dynamic widget coming from the state.</p><ul><li><code>∀ w. w == stateful w dynamic</code></li></ul></div></div><h3 id="useful-combinators"><a href="#useful-combinators" class="anchor"></a>Useful combinators</h3><p>The following are defined from the previous combinators.</p><div class="odoc-spec"><div class="spec value" id="val-of_list" class="anchored"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_list ws</code> displays the static list of widget <code>ws</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-list" class="anchored"><a href="#val-list" class="anchor"></a><code><span><span class="keyword">val</span> list : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>list w</code> displays a dynamic list, using the widget <code>w</code> for each element.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(&lt;*&gt;)" class="anchored"><a href="#val-(&lt;*&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;*&gt;) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>a &lt;*&gt; b</code> is the product of the two widgets <code>a</code> and <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cond" class="anchored"><a href="#val-cond" class="anchor"></a><code><span><span class="keyword">val</span> cond : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>cond p w</code> renders the widget <code>w</code> when the predicate <code>p</code> is satisfied.</p><ul><li>identities: <code>∀ p. cond p empty == empty</code> and <code>∀ w. cond (fun _ -&gt; true) w == w</code> and <code>∀ w. cond (fun _ -&gt; false) w == empty</code></li><li>composition: <code>∀ p q w.  cond p (cond q w) == cond (fun x -&gt; p x &amp;&amp; q x) w</code></li><li>distributive: <code>∀ p a b. cond p (a &amp; b) == cond p a &amp; cond p b</code></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-ifte" class="anchored"><a href="#val-ifte" class="anchor"></a><code><span><span class="keyword">val</span> ifte : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>ifte p if_true if_false</code> renders the widget <code>if_true</code> when <code>p</code> is satisfied, otherwise <code>if_false</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cond_forget" class="anchored"><a href="#val-cond_forget" class="anchor"></a><code><span><span class="keyword">val</span> cond_forget : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Same as <code>cond</code>, but the internal state is lost when the predicate is unsatisfied (see <a href="#val-case"><code>case</code></a>).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stateful_by" class="anchored"><a href="#val-stateful_by" class="anchor"></a><code><span><span class="keyword">val</span> stateful_by : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'s</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'s</span> * <span class="type-var">'a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>stateful_by f w</code> is the same as <code>stateful</code>, but the initial value is computed from the current state.</p></div></div><h3 id="recursive-definitions"><a href="#recursive-definitions" class="anchor"></a>Recursive definitions</h3><p>As OCaml is a strict language, recursive definitions need special support as this would fail to terminate:</p><pre><code>let rec list w = into Prism.cons (w &lt;*&gt; list w)</code></pre><p>and one should rather delay slightly the recursion:</p><pre><code>let rec list w = into Prism.cons (w &lt;*&gt; apply list w)</code></pre><div class="odoc-spec"><div class="spec value" id="val-of_lazy" class="anchored"><a href="#val-of_lazy" class="anchor"></a><code><span><span class="keyword">val</span> of_lazy : <span><span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="xref-unresolved">Stdlib</span>.Lazy.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_lazy w</code> delays the lazy widget <code>w</code>, such that <code>of_lazy (lazy w) == w</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-apply" class="anchored"><a href="#val-apply" class="anchor"></a><code><span><span class="keyword">val</span> apply : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>apply f x</code> is <code>of_lazy (lazy (f x))</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fix" class="anchored"><a href="#val-fix" class="anchor"></a><code><span><span class="keyword">val</span> fix : <span><span>( <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>fix f</code> uses <code>of_lazy</code> to simplify the definition of recursive traversals.</p></div></div><h2 id="html-primitive-widgets"><a href="#html-primitive-widgets" class="anchor"></a>HTML primitive widgets</h2><div class="odoc-spec"><div class="spec value" id="val-str" class="anchored"><a href="#val-str" class="anchor"></a><code><span><span class="keyword">val</span> str : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>str s</code> displays the constant string <code>s</code> as HTML.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-text" class="anchored"><a href="#val-text" class="anchor"></a><code><span><span class="keyword">val</span> text : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> string )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>text f</code> renders a dynamic string using the function <code>f</code> on the current state.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-checkbox" class="anchored"><a href="#val-checkbox" class="anchor"></a><code><span><span class="keyword">val</span> checkbox : <span>bool <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>checkbox</code> is a primitive widget to render and edit a boolean.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-input_int" class="anchored"><a href="#val-input_int" class="anchor"></a><code><span><span class="keyword">val</span> input_int : <span>int <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>input_int</code> is a primitive widget to render and edit an integer as a text input.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-input_string" class="anchored"><a href="#val-input_string" class="anchor"></a><code><span><span class="keyword">val</span> input_string : <span>string <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>input_string</code> is a primitive widget to render and edit a single-line string.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-button" class="anchored"><a href="#val-button" class="anchor"></a><code><span><span class="keyword">val</span> button : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>button w</code> is an HTML button using the widget <code>w</code> for its contents. The reaction when the button is clicked can be specified with <a href="E/index.html#val-click"><code>E.click</code></a>:</p><pre><code>button (str &quot;Click&quot; &amp; E.click (fun old_state -&gt; new_state))</code></pre></div></div><div class="odoc-spec"><div class="spec module" id="module-H" class="anchored"><a href="#module-H" class="anchor"></a><code><span><span class="keyword">module</span> <a href="H/index.html">H</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>HTML elements and nodes, like div, span, etc.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-A" class="anchored"><a href="#module-A" class="anchor"></a><code><span><span class="keyword">module</span> <a href="A/index.html">A</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>HTML attributes and properties.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-E" class="anchored"><a href="#module-E" class="anchor"></a><code><span><span class="keyword">module</span> <a href="E/index.html">E</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>HTML events.</p></div></div></div></body></html>