<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ocastore (ocastore.Ocastore)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">ocastore</a> &#x00BB; Ocastore</nav><header class="odoc-preamble"><h1>Module <code><span>Ocastore</span></code></h1><p>Build your own distributed database! OCastore provides a database system which smoothly integrate with OCaml values to provide persistent storage and network distribution of your application state.</p><p>Using Ocastore, an application can directly manipulate standard OCaml types and values, with no impedance mismatch with the database model. The values stored in the database are exactly the OCaml values expected by your application, manipulated with regular OCaml code. OCaml types define the database schema, OCaml values are the database and OCaml is the query language.</p><p>This is loosely similar to using <code>Marshal</code> to store OCaml values on disk, but with granular control over the updates (instead of having to load and write the whole database state from / to disk) and with the ability to query the database over the network.</p><p>There are two libraries:</p><ul><li><a href=".">ocastore</a> provides the basic building blocks to define your database schema, queries and database updates. This is the main module to use in your application code.</li></ul><ul><li><a href="../../ocastore-eio/Ocastore_eio/index.html">ocastore-eio</a> to create or use a database stored on disk, or to serve and connect to a remote database over the network.</li></ul></header><nav class="odoc-toc"><ul><li><a href="#database">Database</a></li><li><a href="#links">Links</a></li><li><a href="#Mutablereferences">Mutable references</a><ul><li><a href="#transactions">Transactions</a></li><li><a href="#reactive-programming">Reactive programming</a></li></ul></li><li><a href="#SchemaPPX">Schema PPX</a></li></ul></nav><div class="odoc-content"><h2 id="database"><a href="#database" class="anchor"></a>Database</h2><div class="odoc-spec"><div class="spec type anchored" id="type-schema"><a href="#type-schema" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a schema</span></span><span> = <span><span class="type-var">'a</span> <span class="xref-unresolved">Typerep_lib</span>.Std.Typerep.t</span></span></code></div><div class="spec-doc"><p>The type of a schema describing the representation of an <code>'a</code> value. This is automatically generated by using <code>[@@deriving typerep]</code> on your type definitions. See <a href="#SchemaPPX" title="SchemaPPX">Schema PPX</a>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-db"><a href="#type-db" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a db</span></span></code></div><div class="spec-doc"><p>The type of a database storing a root value of type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create_in_memory"><a href="#val-create_in_memory" class="anchor"></a><code><span><span class="keyword">val</span> create_in_memory : <span><span><span class="type-var">'a</span> <a href="#type-schema">schema</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-db">db</a></span></span></code></div><div class="spec-doc"><p><code>create_in_memory schema v</code> returns a fresh in-memory database initialized to the state <code>v</code> described by the <code>schema</code>.</p><p>Example:</p><pre class="language-ocaml"><code>open Ocastore

type mydb = { what: string; ever: int } [@@deriving show, typerep]

let () =
  (* initialize eio and mirage-crypto *)
  Eio_main.run @@ fun env -&gt;
  Mirage_crypto_rng_eio.run (module Mirage_crypto_rng.Fortuna) env @@ fun () -&gt;

  let initial_value = { what = &quot;fresh&quot;; ever = 42 } in

  let db = create_in_memory typerep_of_mydb initial_value in

  Format.printf &quot;%a@.&quot; pp_mydb (db_get db);
  assert (db_get db = initial_value);

  let new_value = { initial_value with what = &quot;updated&quot; } in
  db_set db new_value;
  Format.printf &quot;%a@.&quot; (db_get db);
  assert (db_get db = new_value);

  db_close db</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-db_close"><a href="#val-db_close" class="anchor"></a><code><span><span class="keyword">val</span> db_close : <span><span><span class="type-var">'a</span> <a href="#type-db">db</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>db_close db</code> disconnects the database <code>db</code>. Further operations on the values stored by the database may fail.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-db_get"><a href="#val-db_get" class="anchor"></a><code><span><span class="keyword">val</span> db_get : <span><span><span class="type-var">'a</span> <a href="#type-db">db</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>db_get db</code> returns the current <code>'a</code> value stored by the database <code>db</code>. Same as <code>get db (db_root db)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-db_set"><a href="#val-db_set" class="anchor"></a><code><span><span class="keyword">val</span> db_set : <span><span><span class="type-var">'a</span> <a href="#type-db">db</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>db_set db x</code> updates the current value stored by the database <code>db</code> to be <code>x</code>. Same as <code>set db (db_root db) x</code>.</p></div></div><h2 id="links"><a href="#links" class="anchor"></a>Links</h2><p>To efficiently store and access very large values, it is necessary to introduce an indirection into the OCaml values manipulated by the database. This indirection permits lazy, on-demand, access to the database sub-values.</p><p>An <code>'a link</code> is a pointer to an <code>'a</code> value, which may reside in memory or on disk or can be acquired by a network call. They come with two operations: one to create a new <code>'a link</code> to an <code>'a</code> value, and one to <a href="#val-fetch"><code>fetch</code></a> the <code>'a</code> value pointed by an <code>'a link</code>. Links behave like the identity type over <code>'a</code> such that you may consider the equality <code>'a link ~= 'a</code> to hold when reasonning about your program behaviour.</p><p>Links adds a serialization boundary to OCaml values: Their pointed value will only be read from disk/network on demand when calling <a href="#val-fetch"><code>fetch</code></a>. By adding <code>link</code> annotations into OCaml types and values, you can control the granularity of the database access patterns.</p><p>For example:</p><pre class="language-ocaml"><code>type user = { name: string; avatar: Png.t link }
  [@@deriving typerep]</code></pre><p>By adding a <code>link</code> to the <code>avatar</code> field of a user, we can avoid decoding it in queries that don't require it. We also avoid having to re-write the avatar on disk, when some other fields are updated.</p><p>Links are immutable and point to immutable values. Once created, they always point to the same value returned by <a href="#val-fetch"><code>fetch</code></a>. As such, links also provide deduplication of the database values: If two different links are created to point to the same value, this value will only be stored once on disk. When the database is distributed over the network, clients exploit this to avoid fetching links that they have already obtained before.</p><p>Usage of <code>mutable</code> record fields, <code>ref</code>, <code>array</code>, <code>Atomic.t</code> etc is forbidden since those updates will not be seen by the OCastore database and will not be reflected on disk/network. See <a href="#Mutablereferences" title="Mutablereferences">Mutable references</a> to introduce granular mutations into your database.</p><div class="odoc-spec"><div class="spec type anchored" id="type-link"><a href="#type-link" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a link</span></span></code></div><div class="spec-doc"><p>The type of links pointing to an <code>'a</code> value. The pointed <code>'a</code> value can be obtained with <a href="#val-fetch"><code>fetch</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-link"><a href="#val-link" class="anchor"></a><code><span><span class="keyword">val</span> link : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-link">link</a></span></span></code></div><div class="spec-doc"><p><code>link x</code> returns a new link to the value <code>x</code>.</p><p>The address of a link to a value <code>x</code> is the content hash of the value <code>x</code>. As a result, two different links pointing to the same value will have the same address and will eventually be deduplicated. In practice, it means that the value <code>x</code> will be stored only once on disk and will be fetched only once over the network.</p><pre class="language-ocaml"><code>link (fetch l) ~= l</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fetch"><a href="#val-fetch" class="anchor"></a><code><span><span class="keyword">val</span> fetch : <span><span><span class="type-var">'a</span> <a href="#type-link">link</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>fetch lnk</code> returns the value pointed by the link <code>lnk</code>.</p><pre class="language-ocaml"><code>fetch (link x) ~= x</code></pre></div></div><p>The loose equality <code>~=</code> is only there to indicate that OCaml <code>(=)</code> builtin equality may not hold, even though the values are conceptually equal (and often even physically equal).</p><p>When designing your database model, you can start with standard OCaml types and values. Once you know your access patterns, you can introduce <code>link</code> annotations into your types to indicate that a sub-value is likely to survive database updates and/or will only rarely be accessed. This granularity will be exploited by Ocastore to update the disk and network clients more efficiently.</p><p>Since links are immutable, they encourage the use of purely functional datastructures. For example, you can adapt an existing datastructure by annotating each level of the recursion:</p><pre class="language-ocaml"><code>type t = s link
and s = Leaf | Bin of t * t
[@@deriving typerep]</code></pre><p>Fixing the algorithms is then a matter of following the typechecker to introduce <a href="#val-link"><code>link</code></a> and <a href="#val-fetch"><code>fetch</code></a> appropriately. When updating such a datastructure, only the newly created links will need to be stored. This enables purely functional updates, which share a large part of the previous version, to run with the expected complexity.</p><p><b>TODO:</b> Add stdlib-compatible implementations of <code>Set</code>, <code>Map</code>, etc.</p><h2 id="Mutablereferences"><a href="#Mutablereferences" class="anchor"></a>Mutable references</h2><p>To scale on multiple cores and on distributed systems, it is necessary to introduce mutable granularity instead of always updating the (highly contentious) root of the database. Since OCaml standard <code>ref</code> and other imperative mutations are unobservable by OCastore (which wouldn't be able to replicate the changes on disk or over the network), a new type is required to explicit mutations.</p><div class="odoc-spec"><div class="spec type anchored" id="type-mut"><a href="#type-mut" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a mut</span></span></code></div><div class="spec-doc"><p>The type of mutable references storing a value of type <code>'a</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mut"><a href="#val-mut" class="anchor"></a><code><span><span class="keyword">val</span> mut : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-mut">mut</a></span></span></code></div><div class="spec-doc"><p><code>mut x</code> returns a fresh mutable reference initialized to the value <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-db_root"><a href="#val-db_root" class="anchor"></a><code><span><span class="keyword">val</span> db_root : <span><span><span class="type-var">'a</span> <a href="#type-db">db</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-mut">mut</a></span></span></code></div><div class="spec-doc"><p><code>db_root db</code> returns the mutable root of the database.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><span><span class="type-var">_</span> <a href="#type-db">db</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-mut">mut</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>get db m</code> returns the current value of the reference <code>m</code> in the database <code>db</code>. Same as <code>transaction db (read m)</code>.</p><p>The mutable reference <code>m</code> may exists in multiple databases, but with a different current value in each.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set"><a href="#val-set" class="anchor"></a><code><span><span class="keyword">val</span> set : <span><span><span class="type-var">_</span> <a href="#type-db">db</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-mut">mut</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set db m x</code> updates the reference <code>m</code> to now hold the value <code>x</code> in the database <code>db</code>. Same as <code>transaction db (write m x)</code>.</p></div></div><h3 id="transactions"><a href="#transactions" class="anchor"></a>Transactions</h3><p>To update or read multiple references all at once, in a linearizable way. This is the recommended way to query and update mutable references, since it offers more control over last-writer-win dataraces.</p><div class="odoc-spec"><div class="spec type anchored" id="type-tx"><a href="#type-tx" class="anchor"></a><code><span><span class="keyword">type</span> tx</span></code></div><div class="spec-doc"><p>The type of a mutable transaction, reading and writing multiple mutable references.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-transaction"><a href="#val-transaction" class="anchor"></a><code><span><span class="keyword">val</span> transaction : <span><span><span class="type-var">_</span> <a href="#type-db">db</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="label">tx</span>:<a href="#type-tx">tx</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>transaction db fn</code> runs the function <code>fn ~tx</code> in a new transaction <code>tx</code> over the database <code>db</code>. The updates of the transaction are made visible all at once. The function <code>fn</code> is expected to perform no other side-effects and to be quick: It may be called multiple times until it succeeeds (or aborts the transaction with an exception).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read"><a href="#val-read" class="anchor"></a><code><span><span class="keyword">val</span> read : <span><span class="label">tx</span>:<a href="#type-tx">tx</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-mut">mut</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>read ~tx m</code> returns the current value of the reference <code>m</code> inside the transaction <code>tx</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-write"><a href="#val-write" class="anchor"></a><code><span><span class="keyword">val</span> write : <span><span class="label">tx</span>:<a href="#type-tx">tx</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-mut">mut</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>write ~tx m x</code> updates the current value of the reference <code>m</code> inside the transaction <code>tx</code>. The change will only be visible by others once the transaction completes.</p></div></div><h3 id="reactive-programming"><a href="#reactive-programming" class="anchor"></a>Reactive programming</h3><p>Updates to mutable references can be observed by watchers, to provide reactive programming (e.g. to update the corresponding field in a GUI).</p><div class="odoc-spec"><div class="spec type anchored" id="type-watcher"><a href="#type-watcher" class="anchor"></a><code><span><span class="keyword">type</span> watcher</span></code></div><div class="spec-doc"><p>The type of a watcher observing the changes made to a mutable reference.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-watch"><a href="#val-watch" class="anchor"></a><code><span><span class="keyword">val</span> watch : <span><span><span class="type-var">_</span> <a href="#type-db">db</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-mut">mut</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-watcher">watcher</a></span></code></div><div class="spec-doc"><p><code>watch db m fn</code> will call <code>fn</code> for every new value affected to the mutable reference <code>m</code> in the database <code>db</code>. Returns a <a href="#type-watcher"><code>watcher</code></a> that can be disabled with <a href="#val-watch_stop"><code>watch_stop</code></a> when no longer needed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-watch_stop"><a href="#val-watch_stop" class="anchor"></a><code><span><span class="keyword">val</span> watch_stop : <span><a href="#type-watcher">watcher</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>watch_stop w</code> remove the watcher <code>w</code>. Its corresponding function will not be called anymore.</p></div></div><h2 id="SchemaPPX"><a href="#SchemaPPX" class="anchor"></a>Schema PPX</h2><p>Schemas describe the OCaml type definitions to the OCastore database. The schemas should be automatically generated by adding <code>[@@deriving typerep]</code> on the OCaml type definitions:</p><pre class="language-ocaml"><code>type t = ... [@@deriving typerep]</code></pre><p>The deriving PPX automatically generates a value <code>typerep_of_t : t schema</code> (where the name <code>t</code> is the name you chose for your type), which can be given to the functions that create a database.</p><p>The following definitions are intended to be used by the PPX, not by users:</p><div class="odoc-spec"><div class="spec value anchored" id="val-typerep_of_link"><a href="#val-typerep_of_link" class="anchor"></a><code><span><span class="keyword">val</span> typerep_of_link : <span><span><span class="type-var">'a</span> <a href="#type-schema">schema</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-link">link</a></span> <a href="#type-schema">schema</a></span></span></code></div><div class="spec-doc"><p><code>typerep_of_link schema</code> is the schema description of links pointing to an arbitrary <code>'a</code> value described by <code>schema</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-typerep_of_mut"><a href="#val-typerep_of_mut" class="anchor"></a><code><span><span class="keyword">val</span> typerep_of_mut : <span><span><span class="type-var">'a</span> <a href="#type-schema">schema</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-mut">mut</a></span> <a href="#type-schema">schema</a></span></span></code></div><div class="spec-doc"><p><code>typerep_of_mut schema</code> is the schema description of mutable references to an arbitrary <code>'a</code> value described by <code>schema</code>.</p></div></div><p>You may have to <code>open Typerep_lib.Std</code> if the following aliases aren't sufficient:</p><div class="odoc-spec"><div class="spec value anchored" id="val-typerep_of_unit"><a href="#val-typerep_of_unit" class="anchor"></a><code><span><span class="keyword">val</span> typerep_of_unit : <span>unit <a href="#type-schema">schema</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-typerep_of_bool"><a href="#val-typerep_of_bool" class="anchor"></a><code><span><span class="keyword">val</span> typerep_of_bool : <span>bool <a href="#type-schema">schema</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-typerep_of_char"><a href="#val-typerep_of_char" class="anchor"></a><code><span><span class="keyword">val</span> typerep_of_char : <span>char <a href="#type-schema">schema</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-typerep_of_int"><a href="#val-typerep_of_int" class="anchor"></a><code><span><span class="keyword">val</span> typerep_of_int : <span>int <a href="#type-schema">schema</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-typerep_of_float"><a href="#val-typerep_of_float" class="anchor"></a><code><span><span class="keyword">val</span> typerep_of_float : <span>float <a href="#type-schema">schema</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-typerep_of_string"><a href="#val-typerep_of_string" class="anchor"></a><code><span><span class="keyword">val</span> typerep_of_string : <span>string <a href="#type-schema">schema</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-typerep_of_list"><a href="#val-typerep_of_list" class="anchor"></a><code><span><span class="keyword">val</span> typerep_of_list : <span><span><span class="type-var">'a</span> <a href="#type-schema">schema</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <a href="#type-schema">schema</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-typerep_of_array"><a href="#val-typerep_of_array" class="anchor"></a><code><span><span class="keyword">val</span> typerep_of_array : <span><span><span class="type-var">'a</span> <a href="#type-schema">schema</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <a href="#type-schema">schema</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-typerep_of_tuple2"><a href="#val-typerep_of_tuple2" class="anchor"></a><code><span><span class="keyword">val</span> typerep_of_tuple2 : <span><span><span class="type-var">'a</span> <a href="#type-schema">schema</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-schema">schema</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-schema">schema</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-typerep_of_tuple3"><a href="#val-typerep_of_tuple3" class="anchor"></a><code><span><span class="keyword">val</span> typerep_of_tuple3 : 
  <span><span><span class="type-var">'a</span> <a href="#type-schema">schema</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-schema">schema</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'c</span> <a href="#type-schema">schema</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> <a href="#type-schema">schema</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-typerep_of_tuple4"><a href="#val-typerep_of_tuple4" class="anchor"></a><code><span><span class="keyword">val</span> typerep_of_tuple4 : 
  <span><span><span class="type-var">'a</span> <a href="#type-schema">schema</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-schema">schema</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'c</span> <a href="#type-schema">schema</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'d</span> <a href="#type-schema">schema</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span> * <span class="type-var">'d</span>)</span> <a href="#type-schema">schema</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-typerep_of_tuple5"><a href="#val-typerep_of_tuple5" class="anchor"></a><code><span><span class="keyword">val</span> typerep_of_tuple5 : 
  <span><span><span class="type-var">'a</span> <a href="#type-schema">schema</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-schema">schema</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'c</span> <a href="#type-schema">schema</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'d</span> <a href="#type-schema">schema</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'e</span> <a href="#type-schema">schema</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span> * <span class="type-var">'d</span> * <span class="type-var">'e</span>)</span> <a href="#type-schema">schema</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-value_tuple0"><a href="#val-value_tuple0" class="anchor"></a><code><span><span class="keyword">val</span> value_tuple0 : <span class="xref-unresolved">Typerep_lib</span>.Std.tuple0</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-typename_of_tuple0"><a href="#val-typename_of_tuple0" class="anchor"></a><code><span><span class="keyword">val</span> typename_of_tuple0 : <span><span class="xref-unresolved">Typerep_lib</span>.Std.tuple0 <span class="xref-unresolved">Typerep_lib</span>.Std.Typename.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-typerep_of_tuple0"><a href="#val-typerep_of_tuple0" class="anchor"></a><code><span><span class="keyword">val</span> typerep_of_tuple0 : <span><span class="xref-unresolved">Typerep_lib</span>.Std.tuple0 <a href="#type-schema">schema</a></span></span></code></div></div></div></body></html>
